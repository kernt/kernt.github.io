---
tags:
  - puppet
  - konfigurationsmanagement
---
# puppet4 externe tools ecosystem externel tools

Wenn du die komplette Konfiguration eines laufenden Systems als Puppet Manifest schnell erfassen willst, gibt es ein paar Tools zur Verfügung. In diesem Beispiel werden wir auf Blueprint schauen, der entworfen ist, um eine Maschine zu untersuchen und seinen Zustand als Puppencode zu entsorgen.

### Fertig werden

Hier ist, was Sie tun müssen, um Ihr System vorzubereiten, um Blueprint zu verwenden.

Führen Sie den folgenden Befehl aus, um Blueprint zu installieren. Wir verwenden hier die `puppet resource` , um den Zustand des `python-Pip` Pakets zu ändern:
```
[root@cookbook ~]# puppet resource package python-pip ensure=installed
Notice../puppet/Package[python-pi../puppet/ensure: created
package { 'python-pip':
  ensure => '1.3.1-4.el6',
}
[root@cookbook ~]# pip install blueprint
Downloadi../puppet/unpacking blueprint
  Downloading blueprint-3.4.2.tar.gz (59kB): 59kB downloaded
  Running setup.py egg_info for package blueprint
Installing collected packages: blueprint
  Running setup.py install for blueprint
    changing mode of bui../puppet/scripts-2../puppet/blueprint from 644 to 755
...
Successfully installed blueprint
Cleaning up...
```

### Tip
Möglicherweise müssen Sie Git auf Ihrem cookbook Node installieren, wenn es noch nicht installiert ist.

### Wie es geht...

Diese Schritte zeigen Ihnen, wie Sie Blueprint ausführen können:

1. Führen Sie die folgenden Befehle aus:
```
[root@cookbook ~]# mkdir blueprint && cd blueprint
[root@cookbook blueprint]# blueprint create -P blueprint_test
# [blueprint] searching for APT packages to exclude
# [blueprint] searching for Yum packages to exclude
# [blueprint] caching excluded Yum packages
# [blueprint] parsing blueprintignore(5) rules
# [blueprint] searching for npm packages
# [blueprint] searching for configuration files
# [blueprint] searching for APT packages
# [blueprint] searching for PE../puppet/PECL packages
# [blueprint] searching for Python packages
# [blueprint] searching for Ruby gems
# [blueprint] searching for software built from source
# [blueprint] searching for Yum packages
# [blueprint] searching for service dependencies
blueprint_te../puppet/manifes../puppet/init.pp
```

2. Lesen Sie die Datei `blueprint_te../puppet/manifes../puppet/init.pp`, um den generierten Code zu sehen:
```
#
# Automatically generated by blueprint(7).  Edit at your own risk.
#
class blueprint_test {
  Exec {
    path =>../puppet/u../puppet/lib../puppet/qt-3../puppet/bi../puppet/u../puppet/loc../puppet/sbi../puppet/u../puppet/loc../puppet/bi../puppet/sbi../puppet/bi../puppet/u../puppet/sbi../puppet/u../puppet/bi../puppet/ro../puppet/bin',
  }
  Class['sources'] -> Class['files'] -> Class['packages']
    class files {
      file {
       ../puppet/etc':
          ensure => directory;
       ../puppet/e../puppet/aliases.db':
content => template('blueprint_te../puppet/e../puppet/aliases.db'),
          ensure  => file,
group   => root,
          mode    => 0644,
          owner   => root;
'/e../puppet/audit':
          ensure => directory;
'/e../puppet/aud../puppet/audit.rules':
          content => template('blueprint_te../puppet/e../puppet/aud../puppet/audit.rules'),
          ensure  => file,
          group   => root,
          mode    => 0640,
          owner   => root;
       ../puppet/e../puppet/blkid':
          ensure => directory;
'/e../puppet/cron.hourly':
          ensure => directory;
'/e../puppet/cron.hour../puppet/run-backup':
          content => template('blueprint_te../puppet/e../puppet/cron.hour../puppet/run-backup'),
          ensure  => file,
          group   => root,
          mode    => 0755,
owner   => root;
'/e../puppet/crypttab':
          content => template('blueprint_te../puppet/e../puppet/crypttab'),
          ensure  => file,
          group   => root,
          mode    => 0644,
          owner   => root;
```

#### Es gibt mehr...

Blueprint nimmt nur einen Schnappschuss des Systems, wie es steht; Es macht keine intelligenten Entscheidungen, und Blueprint erfasst alle Dateien auf dem System und alle Pakete. Es wird eine Konfiguration generieren, die viel größer ist, als Sie tatsächlich benötigen können. Wenn Sie zum Beispiel einen Server konfigurieren, können Sie festlegen, dass das Apache-Paket installiert sein soll. Die Abhängigkeiten für das Apache-Paket werden automatisch installiert und Sie müssen sie angeben. Bei der Erstellung der Konfiguration mit einem Tool wie Blueprint erfassen Sie alle diese Abhängigkeiten und sperren die Versionen, die derzeit auf Ihrem System installiert sind. Wenn wir unseren generierten Blueprint-Code betrachten, können wir sehen, dass dies der Fall ist:
```
class yum {
  package {
    'GeoIP':
      ensure => '1.5.1-5.el6.x86_64';
    'PyXML':
      ensure => '0.8.4-19.el6.x86_64';
    'SDL':
      ensure => '1.2.14-3.el6.x86_64';
    'apr':
      ensure => '1.3.9-5.el6_2.x86_64';
    'apr-util':
      ensure => '1.3.9-3.el6_0.1.x86_64';
```

Wenn du dieses Manifest selbst erschaffst, würdest du wahrscheinlich festlegen, `ensure => installed` einer bestimmten Version installiert ist.

Pakete installieren Standardversionen von Dateien. Blueprint hat keine Ahnung davon und fügt alle Akten dem Manifest hinzu, auch diejenigen, die sich nicht verändert haben. Standardmäßig wird Blueprint wahllos alle Dateien in../puppet/etc` als Datei-Ressourcen erfassen.

Blaupause und ähnliche Werkzeuge haben einen sehr kleinen Gebrauchsfall im Allgemeinen, können aber Ihnen helfen, sich mit der Puppet-Syntax vertraut zu machen und Ihnen einige Ideen zu geben, wie Sie Ihre eigenen Manifeste angeben können. Ich würde es nicht empfehlen, dieses Tool blind zu verwenden, um ein System zu erstellen.

Es gibt keine Abkürzung für ein gutes Konfigurationsmanagement, diejenigen, die hoffen, Zeit und Mühe zu sparen, indem sie einen anderen Code als Ganzes schneiden und einfügen (wie bei öffentlichen Modulen), werden wahrscheinlich auch feststellen, dass es weder spart.